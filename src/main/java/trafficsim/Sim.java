/*
 * SPDX-License-Identifier: AGPL-3.0-only
 */
package trafficsim;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;

import util.Log;

/**
 * Implements the traffic simulation itself, which runs in a separate thread.
 * (GUI repaints are fired after each simulation step.)
 */
public class Sim implements Runnable {
	private DrawingPanel drawingPanel;
	private PixelCoords pixelCoords;
	private RoutePlanner planner;
	private ArrayList<Car> cars;
	private double timestep = 0.08333333333; // Seconds in simulation time between frames. Smaller = more accurate.
	private long accumulatedRunTime = 0; // Updated only on sim pause
	private double time = 0; // Simulation time in seconds
	private int timestepcount = 0; // Count number of time steps elapsed
	private double mindist = 0.01; // 0.01 m, beyond which car positions ignored.
																 // ** It is critical to set this appropriately according to sim timestep!!! **
	private double playthroughRate = 100.0; // Targeted simulation playthrough rate in sim fps. desire ~ 12 fps per second real time.
	// Note: timestep*playthroughRate = sim speed-up/slow-down factor
	private long requiredMaxSimTimePerStep = (long) (1 / playthroughRate * 1000); // in ms
	private Thread thread;
	private volatile boolean runThread = false;
	private boolean preserveStart = false; // Stores whether reset has been hit since pause button
	final long MIN_WAIT_TIME = 0; // ms. Lower is smoother, but more cpu expensive bc of more graphics repaints.
	final int NUM_CARS = 1000; // Pick any number your system can render in real time without lag.

	public static void main(String[] args) {
		Log.warning("Standalone simulation not implemented yet!");
	}

	public Sim(DrawingPanel drawingPanel, PixelCoords pixelCoords) {
		Log.info("Setting up simulation ...");
		this.drawingPanel = drawingPanel;
		this.pixelCoords = pixelCoords;
		planner = new RoutePlanner(pixelCoords.getParser());
		Log.info("Finished setup");
	};

	public void start() {
		if (!preserveStart) { // User has not hit reset since the pause button
			reset();
			// To draw nodes/ways and get bounds
			OsmParser parser = pixelCoords.getParser();
			// Bounds b = parser.getBounds()
			// double deltaLon = b.getDeltaLon();
			// double deltaLat = b.getDeltaLat();
			// TODO Allow specifying inflow/outflow points (via XML file with functions for ex.)
			/*			
			* <Generator>
			*  <Source nodeId="1234">  //originating node
			*   <Random max="1000" />  //value in cars/hr
			*   <Constant value="1000" /> 
			*   <Cosine amplitude="1000" angularFreq="1" phase="45" />  //a*sin(wt+p)
			*   <Exponential amplitude="1000" lifetime="3600">  //a*exp(-T*t), T=tau=1/lambda=mean lifetime in seconds
			*   </Exponential>
			*   <Polyline>  //y_i = m_i*t+b_i, m_i = (t_[i+1]-t_i)/(y_[i+1]-y_i), b_i = y_[i-1](t_i)
			*    <Point time="3600" value="1000"> //time in seconds simulation time
			*    ...
			*   </Polyline>
			*   <Step>  //starts off with time=0, value=0 unless otherwise specified
			*    <Point time="3600" value="1000">
			*    ...
			*   </Step>
			*  </Source>
			*  <Sink>
			*		...
			*		Same as source. Only specify func for one.
			*		If both source and sink functions specified only take source.
			*   If either source/sink unspecified cars generated by source will randomly disperse,
			*    and cars going into sink will be generated from random locations.
			*  </Sink>
			* </Generator>
			*/
			// Add some random cars
			ArrayList<Way> roads = new ArrayList<>(parser.getRoads().values());
			for (int i = 0; i < NUM_CARS; i++) {
				// Note: can't pick nodes at random since majority of nodes won't belong to
				//  proper roads and most cars will be stuck.
				//  Therefore, pick random nodes using traversable ways (roads).
				if (parser.getNodes().isEmpty()) {
					Log.error("No nodes found for simulation");
					return;
				}
				int rand1 = (int) Math.round(Math.random() * (roads.size() - 1));
				int rand2 = (int) Math.round(Math.random() * (roads.size() - 1));
				LinkedList<Node> startNodes = roads.get(rand1).getNodes();
				LinkedList<Node> stopNodes = roads.get(rand2).getNodes();
				int rand3 = (int) Math.round(Math.random() * (startNodes.size() - 1));
				int rand4 = (int) Math.round(Math.random() * (stopNodes.size() - 1));
				Node start = startNodes.get(rand3);
				Node stop = stopNodes.get(rand4);
				// Assign nodes to car and plan route
				Car car = new Car(start.getLon(), start.getLat()); // At random start node
				// Car car = new Car(Math.random()*deltaLon + b.getMinlon(), // Randomly anywhere on map
				//   Math.random()*deltaLat + b.getMinlat());
				if (car.setRoute(planner, start, stop)) {
					// Add car to list if we successfully found a route for it, else forget it
					cars.add(car);
				}
			}
			for (Way way : parser.getWays().values()) {
				drawingPanel.addDrawingObject(way);
				if (way.isRoad()) {
					drawingPanel.addDrawingObjects(new ArrayList<>(way.getNodes()));
				}
			}
			// Draw all vehicles to map
			for (Car c : cars) {
				drawingPanel.addDrawingObject(c);
			}
			Log.debug("Finished simulation start()");
		}
		// Create and start new thread running simulation steps
		runThread = true;
		thread = new Thread(this);
		thread.start();
	}

	@Override
	public void run() {
		long tCatchUp = 0; // catchup time in ms
		long simStartTime = System.currentTimeMillis();
		DecimalFormat df = new DecimalFormat("0.00");
		while (runThread) {
			try {
				// Want playthroughRate simulation steps per timestep.
				// Will wait (timestep/playthroughRate - simStepTime) per step.
				// If negative then subtract from next simulation steps' wait times.
				long tStart = System.currentTimeMillis();
				step();
				drawingPanel.repaint();
				double simRunTime = (System.currentTimeMillis() - simStartTime + accumulatedRunTime) / 1000;
				Log.info("Simulation time (s) : " + df.format(time) + ". Real time (s) : " + simRunTime
						+ ". Average speed-up : " + df.format(time / simRunTime));
				long tStop = System.currentTimeMillis();
				long tWait = requiredMaxSimTimePerStep - (tStop - tStart) + tCatchUp; // Note timestep in seconds
				tCatchUp = (tWait <= MIN_WAIT_TIME) ? tWait : 0; // If negative takes away from next wait; else adds to next wait
				if (tWait > MIN_WAIT_TIME) {
					Thread.sleep(tWait);
				}
			} catch (InterruptedException ie) {
				Log.error(ie.toString());
			}
		}
		accumulatedRunTime += System.currentTimeMillis() - simStartTime;
	}

	// Iterate through one step of simulation time
	public void step() {
		// Update traffic lights
		for (Intersection intersection : planner.getIntersections()) {
			intersection.updateStates(timestep);
		}
		// update car positions
		for (Car car : cars) {
			Node next = car.getNextNode();
			if (next == null) {
				// Finished
				// TODO Could delete car here or set new route after certain random time.
				continue;
			}
			// Handle upcoming intersection if present
			boolean doStop = false;
			Intersection inter = next.getIntersection();
			double dInter = Double.MAX_VALUE; // Stores distance to intersection; MAX_VALUE is arbitrary and should never be used
			Node prev = car.getPrevNode();
			// Don't do intersection code if car starts travelling at an intersection!
			if (prev != null && inter != null) {
				// Code for 4-way stop
				if (inter.getType() == Intersection.ALL_WAY_STOP) {
					// Car not in list of cars polled off intersection queue so must queue and wait at stop
					if (!inter.getPolledCars().contains(car)) {
						doStop = true;
						dInter = ProjectionConverter.getDistBetweenPoints(car.getLon(), car.getLat(), next.getLon(), next.getLat());
						// Queue car if: (a) first in lane, and (b) almost stopped at intersection, and (c) close to intersection.
						// Lane lane = car.getCurrentWay().getLane(car.getWayDirection());
						// boolean isFirst = lane.getCars().getFirst().equals(car);
						// Note: remove first in lane and replace by distance since lane spans multiple lights!
						//  Follow model ensures car isn't too close.
						if (dInter < Car.STOP_DIST && car.getVelocity() < Car.ROLLING_STOP_SPEED) {
							// TODO Below inefficient
							// Add car to queue if lead has already been added to queue
							Car lead = car.getLeader();
							if (lead == null || lead.getNextNode() == null || !lead.getNextNode().equals(car.getNextNode())
									|| inter.getPolledCars().contains(lead) || inter.isQueued(lead)) {
								// TODO Only add if not in queue -> isQueued(car). Depends on which performs better. (Store in car?)
								inter.queue(car);
							}
						}
					} else {
						// Car's turn to go (only actually removed from polled cars list once past intersection)
						doStop = false;
					}
					// Unqueue next car if empty. Cars removed from polled cars as they exit intersection.
					if (inter.getPolledCars().isEmpty()) {
						inter.unqueueNext();
					}
				}
				// Code for fully lit intersection
				else if (inter.getType() == Intersection.FULLY_LIT) {
					// TODO Start checking from earlier nodes to make sure we can stop in time
					if (inter.getState(prev) == Intersection.GREEN) {
						doStop = false;
					} else if (inter.getState(prev) == Intersection.RED) {
						doStop = true;
						dInter = ProjectionConverter.getDistBetweenPoints(car.getLon(), car.getLat(), next.getLon(), next.getLat());
					} else if (inter.getState(prev) == Intersection.YELLOW) {
						// IF we can safely stop, do so
						doStop = false;
						double tStop = Math.abs(car.getVelocity() / car.getMaxDeceleration());
						double dStop = car.getVelocity() * tStop + 0.5 * car.getMaxDeceleration() * tStop * tStop;
						dInter = ProjectionConverter.getDistBetweenPoints(car.getLon(), car.getLat(), next.getLon(), next.getLat());
						if (dStop < dInter) {
							doStop = true;
						}
						// TODO use yellowTime to see if car will run red unavoidably and then delay traffic?
						// double t = inter.getYellowTime(car);
					}
					// For fully lit intersections with traffic controllers add car to
					//  queue on red light to let controller know # cars.
					if (doStop) {
						inter.queue(car);
					}
				}
			}
			// Next we calculate our car's applied acceleration at this timestep:
			// 1. if we must stop for an intersection we calculate acc_intersection
			// 2. calculate desired following/free acceleration acc_follow
			// if (1 and 1 < 2) use 1 else 2
			double a;
			// TODO Integrate stop acceleration into car acceleration when want to do stop.
			//  (Better simulation for hills, etc.)
			double aInter = Double.MAX_VALUE; // arbitrary
			if (doStop) {
				// Required deceleration to stop in time. No need for optimization just solve.
				// t = v/a
				// x = vt - 0.5at^2 = v^2/a - 0.5v^2/a = 0.5v^2/a -> a = 0.5*v^2/x
				if (dInter == Double.MAX_VALUE) {
					Log.error("Intersection distance not initialised for car : " + car.getId() + " node : "
							+ car.getNextNode().getId());
				}
				double aReq = (dInter == 0) ? Double.MIN_VALUE : -0.5 * car.getVelocity() * car.getVelocity() / dInter;
				if (aReq < car.getMaxDeceleration()) {
					aReq = car.getMaxDeceleration();
				}
				aInter = aReq;
				// aInter = car.getDeceleration() // Use simple linearly increasing acceleration model
			}
			// Following acceleration
			double aFollow = car.getAccIdm();
			// aFollow = car.getAcceleration(); // Use simple linearly decreasing acceleration model
			// Note: aInter is always negative. If it's super-small then car doesn't need
			//  to deaccelerate much to intersection so use aFollow instead to get there faster.
			//  Alternatively, if car is at the intersection then just continue with stopping.
			if (doStop && aInter < aFollow && (aInter < Car.SLOWEST_STOP_ACC || dInter < Car.STOP_DIST)) {
				// aInter will be negative
				a = aInter;
			} else {
				a = aFollow;
			}
			// Calculate next timestep speed along way; conform speed to road limits
			// v' = v - a*dt
			Way currentWay = car.getCurrentWay();
			double nextV = car.getVelocity() + a * timestep;
			if (nextV < 0) {
				nextV = 0;
			} else if (currentWay != null) {
				if (nextV > currentWay.getMaxspeedM()) {
					nextV = currentWay.getMaxspeedM();
				}
			} else { // No way so offroad
				nextV = RoadTypes.SPD_SLOW; // Offroad set to slowest speed
			}
			// Calulate car distance to travel, in metres.
			car.setVelocity(nextV);
			double travelDist = car.getVelocity() * timestep;
			// Sort out new car position.
			calculateNewPos(car, travelDist);
		}
		time += timestep;
		timestepcount++;
	}

	private void calculateNewPos(Car car, double travelDist) { // , Iterator<Car> it) {
		if (travelDist > mindist) {
			Node next = car.getNextNode();
			// Get distance and fraction of the distance between car and next node
			double dist = ProjectionConverter.getDistBetweenPoints(car.getLon(), car.getLat(), next.getLon(), next.getLat());
			// Note: dist could be zero if car is at first node
			double frac = (dist == 0) ? Double.MAX_VALUE : travelDist / dist; // MAX_VALUE since not used, arbitrary > 1
			if (frac > 1) {
				// Don't bother calculating, set position to next node in path
				car.setLon(next.getLon());
				car.setLat(next.getLat());
				// If next is an intersection remove car from its list of unqueued (== "polled") cars.
				// This frees up intersection to poll another car off its queues.
				Intersection inter = next.getIntersection();
				if (inter != null) {
					if (inter.getType() == Intersection.ALL_WAY_STOP) {
						inter.forgetPolled(car);
						if (inter.getPolledCars().contains(car)) {
							Log.debug("Could not remove car " + car.getId() + " from list of polled cars for intersection "
									+ inter.getId());
						}
					} else if (inter.getType() == Intersection.FULLY_LIT) {
						inter.remove(car);
					} else {
						Log.warning("Have not implemented this intersection type: " + inter.getType());
					}
				}
				// Check if next node is on current way, if not reassign car to next way
				Way currentWay = car.getCurrentWay();
				if (!currentWay.getNodeRefs().contains(next.getId())) {
					ArrayList<Node> nextNodes = new ArrayList<>();
					nextNodes.add(next);
					Node nextnext = car.getNextNextNode();
					if (nextnext != null) {
						nextNodes.add(nextnext);
					}
					Way nextWay = planner.getFirstOtherRoadContaining(currentWay, nextNodes);
					currentWay.remove(car); // Must call while car's current way is still this!
					car.setCurrentWay(nextWay); // Regardless of nullness!
					if (nextWay != null) {
						nextWay.insert(car);
					} else {
						// Must be going offroad, or bad route (recalculate).
						// TODO Offroad handling code if needed
						Log.warning("Car travelling offroad of way : " + currentWay.getId() + " to node : " + next.getId());
					}
				}
				// Reassign next node to be the next in the path. If car finished, remove from current way.
				car.nextNode();
				// If next is null, car is finished
				if (car.getNextNode() == null) {
					return;
				}
			} else {
				// Get new car position
				double[] newCoords = ProjectionConverter.getPointBetweenPoints(car.getLon(), car.getLat(), next.getLon(),
						next.getLat(), frac);
				car.setLon(newCoords[0]);
				car.setLat(newCoords[1]);
			}
			// If leftover car distance to travel recurse to calculate new position
			double distLeft = travelDist - dist;
			if (distLeft > mindist) {
				calculateNewPos(car, distLeft);
			}
		}
	}

	public void reset() {
		stop();
		time = 0;
		accumulatedRunTime = 0;
		preserveStart = false;
		// Reset drawing objects
		cars = new ArrayList<>();
		drawingPanel.clear();
	}

	public void stop() {
		// Stops run thread
		if (thread != null) {
			runThread = false;
			preserveStart = true;
			try {
				thread.join();
			} catch (InterruptedException ex) {
				Logger.getLogger(Sim.class.getName()).log(Level.SEVERE, null, ex);
			}
		}
	}

	public DrawingPanel getDrawingPanel() {
		return drawingPanel;
	}

	public PixelCoords getPixelCoords() {
		return pixelCoords;
	}

	public double getTimestep() {
		return timestep;
	}

	public double getTime() {
		return time;
	}

	public int getTimestepCount() {
		return timestepcount;
	}

	public double getMindist() {
		return mindist;
	}

	public double getPlaythroughRate() {
		return playthroughRate;
	}

	public void setDrawingPanel(DrawingPanel drawingPanel) {
		this.drawingPanel = drawingPanel;
	}

	public void setPixelCoords(PixelCoords pixelCoords) {
		this.pixelCoords = pixelCoords;
	}

	public void setTimestep(double timestep) {
		this.timestep = timestep;
	}

	public void setMindist(double mindist) {
		this.mindist = mindist;
	}

	public void setPlaythroughRate(double playthroughRate) {
		this.playthroughRate = playthroughRate;
		requiredMaxSimTimePerStep = (long) (1 / playthroughRate * 1000); // in ms
	}
}
